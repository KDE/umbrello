<chapter id="uml-basics">
<title
>Основы &UML;</title>
<sect1 id="about-uml">
<title
>О языке &UML;</title>
<para
>Данный раздел предоставит вам небольшой обзор основ &UML;. Он не является учебником по &UML;, и если вы хотите узнать побольше об &UML; или в целом о планировании разработки программного обеспечения, обратитесь к одной из многих книг по данной теме. В Интернете есть много учебных пособий, можете начать с них. </para>

<para
>Унифицированный язык моделирования (&UML;) является языком диаграмм или обозначений для спецификации, визуализации и документации модели объектно-ориентированных программных систем. &UML; не является методом разработки, то есть он не определяет последовательность действий при разработке программного обеспечения. Он помогает описать свою идею и взаимодействовать с другими разработчиками системы. &UML; управляется Object Management Group (OMG) и является промышленным стандартом, описывающим модели программного обеспечения. </para>
<para
>&UML; создан для применения в разработке объектно-ориентированного программного обеспечения, и с некоторыми ограничениями может применяться для других парадигм программирования. </para>
<para
>&UML; состоит из множества модельных элементов, которые представляют различные компоненты разрабатываемой системы. Элементы &UML; используются для создания диаграмм, которые описывают определённую часть системы или точку зрения на неё. &umbrello; поддерживает следующие типы диаграмм: </para>

<itemizedlist>

<listitem
><para
><emphasis
><link linkend="use-case-diagram"
>Диаграммы вариантов использования</link
></emphasis
> отображают действующих лиц (людей или пользователей системы), варианты использования (сценарии использования системы) и их взаимодействие.</para
> </listitem>

<listitem
><para
><emphasis
><link linkend="class-diagram"
>Диаграммы классов</link
></emphasis
> отображают классы и взаимодействие между ними.</para
> </listitem>

<listitem
><para
><emphasis
><link linkend="sequence-diagram"
>Диаграммы последовательностей</link
></emphasis
> отображают объекты и их взаимодействие, выделяя хронологию обмена сообщениями между объектами.</para
> </listitem>

<listitem
><para
><emphasis
><link linkend="collaboration-diagram"
>Диаграммы взаимодействия</link
></emphasis
> отображают объекты и их взаимодействие, выделяя объекты, которые участвуют в обмене сообщениями.</para>
</listitem>

<listitem
><para
><emphasis
><link linkend="state-diagram"
>Диаграммы состояния</link
></emphasis
> отображают состояния, изменения состояний и события в объектах или компонентах системы.</para
> </listitem>

<listitem
><para
><emphasis
><link linkend="activity-diagram"
>Диаграммы активности</link
></emphasis
> отображают активность, состояния и изменения состояний объектов, а также события, возникающие в компонентах системы.</para
></listitem>

<listitem
><para
><emphasis
><link linkend="component-diagram"
>Диаграммы компонентов</link
></emphasis
> показывают компоненты верхнего уровня (такие как KParts или Java Beans).</para
></listitem>

<listitem
><para
><emphasis
><link linkend="deployment-diagram"
>Диаграммы выпуска</link
></emphasis
> показывают экземпляры компонентов и их взаимоотношения.</para
></listitem
> 

</itemizedlist>

</sect1
>   <!-- about-uml -->

<sect1 id="uml-elements"
>  
<title
>Элементы &UML;</title>
<sect2 id="use-case-diagram">
<title
>Диаграмма вариантов использования</title>
<para
>Диаграммы вариантов использования описывают взаимоотношения и зависимости между группами <emphasis
>вариантов использования</emphasis
> и <emphasis
>действующих лиц</emphasis
>, участвующими в процессе.</para>
<para
>Важно понимать, что диаграммы вариантов использования не предназначены для отображения проекта и не могут описывать внутреннее устройство системы. Диаграммы вариантов использования предназначены для упрощения взаимодействия с будущими пользователями системы, с клиентами, и особенно пригодятся для определения необходимых характеристик системы. Другими словами, диаграммы вариантов использования говорят о том, <emphasis
>что</emphasis
> система должна делать, не указывая <emphasis
>сами</emphasis
> применяемые методы.</para>
<para>
<screenshot>
<screeninfo
>Пример диаграммы вариантов использования.</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="use-case-diagram.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Диаграмма вариантов использования</phrase>
	  </textobject>
	  <caption>
	    <para
>Диаграмма вариантов использования </para>
	  </caption>
	</mediaobject>
</screenshot>
</para>
<sect3 id="use-case">
<title
>Вариант использования</title>
<para
><emphasis
>Вариант использования</emphasis
> описывает, с точки зрения действующего лица, группу действий в системе, которые приводят к конкретному результату.</para>
<para
>Варианты использования являются описаниями типичных взаимодействий между пользователями системы и самой системой. Они отображают внешний интерфейс системы и указывают форму того, что система должна сделать (именно что, а не как). </para>
<para
>При работе с вариантами использования важно помнить несколько простых правил: <itemizedlist>
 <listitem
><para
>Каждый вариант использования относится как минимум к одному действующему лицу</para
></listitem>
 <listitem
><para
>Каждый вариант использования имеет инициатора</para
></listitem>
 <listitem
><para
>Каждый вариант использования приводит к соответствующему результату (результату с <quote
>бизнес-значением</quote
>).</para>
 </listitem>
 </itemizedlist>
</para>
<para
>Варианты использования также могут взаимодействовать с другими вариантами использования. Три наиболее часто встречающихся типа взаимодействия между вариантами использования приведены ниже:</para>
<itemizedlist>
<listitem
><para
><emphasis
>&lt;&lt;включение&gt;&gt;</emphasis
> указывает, что вариант использования встраивается <emphasis
>в</emphasis
> другой вариант использования;</para
></listitem>
<listitem
><para
><emphasis
>&lt;&lt;добавление&gt;&gt;</emphasis
> указывает, что в определённых ситуациях или в некоторой точке (называемой точкой расширения) вариант использования будет расширен другим;</para
></listitem>
<listitem
><para
><emphasis
>&lt;&lt;обобщение&gt;&gt;</emphasis
> указывает, что вариант  использования наследует характеристики <quote
>родительского</quote
> варианта использования и может переопределить некоторые из них или добавить новые, подобно наследованию в классах. </para>
</listitem>
</itemizedlist>
</sect3>
<sect3 id="actor">
<title
>Действующее лицо</title>
<para
>Действующее лицо является внешним источником (не элементом системы), который взаимодействует с системой через вариант использования. Действующие лица могут быть как реальными людьми (например, пользователями системы), так и другими компьютерными системами или внешними событиями. </para>
<para
>Действующие лица представляют не <emphasis
>физических</emphasis
> людей или системы, а их <emphasis
>роли</emphasis
>. Эти означает, что когда человек взаимодействует с системой различными способами (предполагая различные роли), он отображается несколькими действующими лицами. Например, человек, работающий в службе поддержки и принимающий от клиентов заказы, будет отображаться в системе как <quote
>участник отдела поддержки</quote
> и <quote
>участник отдела продаж</quote
>. </para>
</sect3>
<sect3 id="use-case-description">
<title
>Описание варианта использования</title>
<para
>Описания вариантов использования являются текстовыми пояснениями варианта использования. Они обычно принимают форму заметки или документа, который каким-то образом прикрепляется к варианту использования и описывает процесс или активность, который имеет место быть в варианте использования. </para>
</sect3>
</sect2
> <!-- use-case-diagram -->

<sect2 id="class-diagram">
<title
>Диаграмма класса</title>
<para
>Диаграммы классов отображают различные классы, из которых состоит система, и их взаимодействие между собой. Диаграммы классов являются <quote
>статичными</quote
> диаграммами, потому что они отображают классы вместе с их методами и атрибутами, так же как и статические взаимодействия между ними: какие классы <quote
>знают</quote
> о каких классах или какие классы <quote
>являются частью</quote
> других классов, но не отображают обмен сообщениями между классами. </para>
<para>
<screenshot>
<screeninfo
>Пример диаграммы класса</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="class-diagram.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Диаграмма класса</phrase>
	  </textobject>
	  <caption>
	    <para
>Диаграмма класса </para>
	  </caption>
	</mediaobject>
</screenshot>
</para>
<sect3 id="class">
<title
>Класс</title>
<para
>Класс определяет атрибуты и методы набора объектов. Все объекты класса (называемые экземплярами) имеют одинаковое поведение и одинаковый набор атрибутов (у каждого объекта - собственный набор атрибутов). Иногда вместо класса используется термин <quote
>тип</quote
>, но важно понимать, что эти термины неодинаковы. Термин <quote
>Тип</quote
> имеет более общий смысл. </para>
<para
>В &UML; классы представлены прямоугольниками с именем класса, которые могут отображать атрибуты и операции класса, помещённые внутри прямоугольника. </para>
<para>
<screenshot>
<screeninfo
>Класс в &UML;</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="class.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Визуальное представление класса в &UML;</phrase>
	  </textobject>
	  <caption>
	    <para
>Визуальное представление класса в &UML; </para>
	  </caption>
	</mediaobject>
</screenshot>
</para>
<sect4 id="attribute">
<title
>Атрибуты</title>
<para
>В &UML; атрибуты отображаются как минимум их названием, но также могут показывать свой тип, начальное значение и другие свойства. Атрибуты также могут отображаться с указанием их области видимости: </para>
<itemizedlist>
<listitem
><para
><literal
>+</literal
> отмечает <emphasis
>public</emphasis
> атрибуты;</para
></listitem>
<listitem
><para
><literal
>#</literal
> отмечает <emphasis
>protected</emphasis
> атрибуты;</para
></listitem>
<listitem
><para
><literal
>-</literal
> отмечает <emphasis
>private</emphasis
> атрибуты.</para
></listitem>
</itemizedlist>
</sect4>
<sect4 id="operation">
<title
>Методы</title>
<para
>Методы (операции) также отображаются как минимум их названием, но также могут показывать свои параметры и возвращаемый тип. Подобно атрибутам, методы имеют область видимости: <itemizedlist>
<listitem
><para
><literal
>+</literal
> отмечает <emphasis
>public</emphasis
> операции;</para
></listitem>
<listitem
><para
><literal
>#</literal
> отмечает <emphasis
>protected</emphasis
> операции;</para
></listitem>
<listitem
><para
><literal
>-</literal
> отмечает <emphasis
>private</emphasis
> операции.</para
></listitem>
</itemizedlist>
</para>
</sect4>

<sect4 id="templates">
<title
>Шаблоны</title>
<para
>Классы могут иметь шаблоны, значение которых используется для неуказанного класса или типа. Тип шаблона указывается при инициализации класса (то есть, при создании объекта). Шаблоны используются в современном C++ и будут введены в Java 1.5, где будут обозначаться как Generics. </para>
</sect4>
</sect3>

<sect3 id="class-associations">
<title
>Ассоциации классов</title>
<para
>Классы могут взаимодействовать друг с другом различными способами:</para>
<sect4 id="generalization">
<title
>Обобщение</title>
<para
>Наследование является основной концепцией объектно-ориентированного программирования, в которой класс <quote
>получает</quote
> все атрибуты и методы наследуемого класса и может переопределять/модифицировать некоторые из них, имея возможность добавлять собственные атрибуты и методы.</para>
<para
>В &UML; ассоциация <emphasis
>обобщения</emphasis
> между двумя классами помещает их в иерархию, представляющую концепцию наследования производного класса от базового. В &UML; обобщения отображаются в виде линии, соединяющей два класса, со стрелочкой у базового класса. <screenshot>
<screeninfo
>Обобщение</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="generalization.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Визуальное представление обобщения в &UML;</phrase>
	  </textobject>
	  <caption>
	    <para
>Визуальное представление обобщения в &UML; </para>
	  </caption>
	</mediaobject>
</screenshot>
</para>
</sect4>

<sect4 id="uml-associations">
<title
>Ассоциации</title>
<para
>Ассоциации отображают взаимодействия между классами и определяют общую семантику и структуру многих типов <quote
>связей</quote
> между объектами.</para>
<para
>Ассоциации являются механизмом, который позволяет объектам взаимодействовать с друг другом. Они описывают связи между различными классами (связи между объектами называются соединениями объектов или <emphasis
>ссылками</emphasis
>. </para>
<para
>Ассоциации могут иметь роль, которая определяет назначение ассоциации и может быть одно- или двунаправленной, показывая, могут ли взаимодействующие объекты обмениваться сообщениями, или только один объект может отсылать сообщения. Каждый конец ассоциации имеет описание множественности, которое указывает, какое количество объектов на этой стороне ассоциации может взаимодействовать с одним объектом на другой стороне. </para>
<para
>В &UML; ассоциации отображаются в виде линии, соединяющей взаимодействующие классы, и могут показывать роль и количество объектов с каждой стороны. Множественность отображается в виде диапазона [мин..макс] неотрицательных значений, звёздочка (<literal
>*</literal
>) в качестве максимального значения обозначает бесконечность. <screenshot>
<screeninfo
>&UML;-ассоциации</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="association.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Визуальное представление ассоциации в &UML;</phrase>
	  </textobject>
	  <caption>
	    <para
>Визуальное представление ассоциации в &UML; </para>
	  </caption>
	</mediaobject>
</screenshot>
</para>
</sect4>

<sect4 id="aggregation">
<title
>Объединение</title>
<para
>Объединения являются специальным типом ассоциаций, в котором два участвующих класса не равнозначны по статусу, но создают взаимодействие типа <quote
>часть-целое</quote
>. Объединение описывает, как класс, играющий роль целого, создаётся из других классов, играющих роль частей. Для объединений класс, выступающий в роли целого, всегда имеет множественность, равную единице. </para>
<para
>В &UML; объединения отображаются в виде линии с ромбом на стороне целого, соединяющей взаимодействующие классы. <screenshot>
<screeninfo
>Объединение</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="aggregation.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Визуальное представление объединения в &UML;</phrase>
	  </textobject>
	  <caption>
	    <para
>Визуальное представление объединения в &UML; </para>
	  </caption>
	</mediaobject>
</screenshot>
</para>
</sect4>
<sect4 id="composition">
<title
>Композиция</title>
<para
>Композиция является ассоциацией, которая представляет <emphasis
>очень тесное</emphasis
> объединение. Это означает, что Композиция формирует взаимодействия типа <quote
>часть-целое</quote
>, но эти взаимодействия настолько сильные, что части не могут существовать сами по себе. Они существуют только внутри целого, и при уничтожении целого уничтожаются и части.</para>
<para
>В &UML; композиции отображаются в виде линии с закрашенным ромбом на стороне целого, соединяющей взаимодействующие классы. </para>
<para
><screenshot>
<screeninfo
>Композиция</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="composition.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Визуальное представление композиции в &UML;</phrase>
	  </textobject>
	</mediaobject>
</screenshot
></para>
</sect4>
</sect3
> <!--class-associations-->

<sect3 id="other-class-diagram-items">
<title
>Другие элементы диаграммы класса</title>
<para
>Диаграммы классов могут содержать другие элементы внутри классов.</para>
<sect4 id="interfaces">
<title
>Интерфейсы</title>
<para
>Интерфейсы являются абстрактными классами, следовательно, объекты данных классов не могут быть созданы напрямую. Они могут содержать методы, но не атрибуты. Классы могут наследоваться от интерфейсов (через ассоциацию реализации), и полученные объекты затем могут использоваться при составлении диаграмм.</para>
<!-- FIXME screenshot -->
</sect4>
<sect4 id="datatype">
<title
>Типы данных</title>
<para
>Типы данных являются примитивами, которые обычно встроены в язык программирования. Яркими примерами могут служить целые и логические типы. Они могут не иметь отношения к классам, но классы могут использовать их.</para>
<!-- FIXME screenshot -->
</sect4>
<sect4 id="enum">
<title
>Перечисления</title>
<para
>Перечисления представляют собой простой список значений. Примером перечисления является перечисление дней недели. Подобно типам данных, они могут использоваться в классах.</para>
<!-- FIXME screenshot -->
</sect4>
<sect4 id="package">
<title
>Пакеты</title>
<para
>Пакеты представляют собой пространства имён в языке программирования. В диаграмме они используются для представления частей системы, которые содержат более одного класса (число классов может превышать несколько сотен).</para>
<!-- FIXME screenshot -->
</sect4>
</sect3>

</sect2
> <!-- class diagram -->

<sect2 id="sequence-diagram">
<title
>Диаграммы последовательностей</title>

<para
>Диаграммы последовательностей показывают обмен сообщениями (то есть вызовы методов) между различными объектами в специфической, ограниченной по времени, ситуации. Диаграммы последовательностей специально выделяют порядок и времена отсылки сообщений объектам.</para>

<para
>В диаграммах последовательностей объекты представляются вертикальными прерывистыми линиями с именем объекта наверху. Временная ось также направлена сверху вниз. Таким образом, сообщения, посылаемые от одного объекта к другому, отображаются стрелками с указанием операции и параметров. </para>

<!-- FIXME update screenshot to show synchronous messages -->
<screenshot>
<screeninfo
>Диаграмма последовательности</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="sequence-diagram.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Диаграмма последовательности</phrase>
	  </textobject>
	  <caption>
	    <para
>Диаграмма последовательности </para>
	  </caption>
	</mediaobject>
</screenshot>

<para
>Сообщения могут быть либо синхронными, когда управление передаётся вызываемому объекту вплоть до момента окончания его работы, либо асинхронными, когда управление сразу же возвращается вызывающему объекту. Синхронные сообщения обозначаются вертикальным прямоугольником на стороне вызываемого объекта для отображения передачи управления в программе.</para>
</sect2
> <!-- sequence diagrams -->

<sect2 id="collaboration-diagram">
<title
>Диаграммы взаимодействий</title>

<para
>Диаграммы взаимодействий показывают взаимодействия между объектами, участвующими в конкретной ситуации. Это более или менее повторяет информацию, отображаемую диаграммами последовательностей, но там основной упор делается на то, как взаимодействия проявляются во времени, а здесь выделяются связи между объектами и их топологией.</para>

<para
>На диаграммах взаимодействий сообщения, пересылаемые от одного объекта к другому, представляются в виде стрелок с указанием имени, параметров и последовательности сообщений. Диаграммы взаимодействий наиболее удачно подходят для отображения процесса работы программы или какой-либо ситуации, а также является лучшим типом диаграмм для демонстрации или объяснения какого-либо процесса в логике программы. </para>

<screenshot>
<screeninfo
>Взаимодействие</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="collaboration-diagram.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Диаграмма взаимодействия</phrase>
	  </textobject>
	  <caption>
	    <para
>Диаграмма взаимодействия </para>
	  </caption>
	</mediaobject>
</screenshot>

</sect2
> <!-- collaboration diagrams -->

<sect2 id="state-diagram">
<title
>Диаграмма состояния</title>
<para
>Диаграммы состояний показывают различные состояния объекта в течение его времени жизни и причины, вызывающие их смену. </para
>                              
<para
>Диаграммы состояний рассматривают объекты как <emphasis
>конечные автоматы</emphasis
>, которые могут быть в одном из нескольких конечных состояний. Конечные состояния могут изменяться с помощью конечного набора причин. Например, объект типа <emphasis
>NetServer</emphasis
> может находиться в одном из следующих состояний: </para>
<itemizedlist>
<listitem
><para
>Готовность</para
></listitem>
<listitem
><para
>Ожидание</para
></listitem>
<listitem
><para
>Обработка</para
></listitem>
<listitem
><para
>Остановка</para
></listitem>
</itemizedlist>
<para
>а события, которые могут привести к смене объектом своего состояния, это:</para>
<itemizedlist>
<listitem
><para
>Создание объекта</para
></listitem>
<listitem
><para
>Объект принял ожидаемое сообщение</para
></listitem>
<listitem
><para
>Клиент запросил соединение по сети</para
></listitem>
<listitem
><para
>Клиент прервал запрос</para
></listitem>
<listitem
><para
>Запрос выполнен</para
></listitem>
<listitem
><para
>Объект получил завершающее сообщение</para
></listitem>
<listitem
><para
>и так далее</para
></listitem>
</itemizedlist>
<para>
<screenshot>
<screeninfo
>Диаграмма состояния</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="state-diagram.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Диаграмма состояния</phrase>
	  </textobject>
	  <caption>
	    <para
>Диаграмма состояния </para>
	  </caption>
	</mediaobject>
</screenshot>
</para>
<sect3 id="state">
<title
>Состояние</title>
<para
>Состояния являются ключевыми элементами диаграмм состояний. Состояния принадлежат ровно одному классу и представляют собой совокупность значений, которые могут принимать атрибуты класса. В &UML; состояние описывает внутреннее состояние объекта одного определённого класса. </para
>                       
<para
>Следует отметить, что не стоит отображать на диаграмме состояний все состояния, отображайте только важные состояния, которые значительно влияют на работу объекта.</para>
<para
>Существуют два особых типа состояний: начало и конец. И вот почему: нет такого события, которое заставит объект возвратиться в состояние начало, если он из него вышел; нет такого события, которое заставит объект выйти из состояния конец, если он в него вошёл. </para>
</sect3>

</sect2
> <!-- state diagrams -->

<sect2 id="activity-diagram">
<title
>Диаграмма действий</title>
<para
>Диаграммы действий описывают последовательность действий в системе с помощью действий. Диаграммы действий являются специальной формой диаграмм состояний, только в основном содержат действия. </para>
<para>
<screenshot>
<screeninfo
>Пример диаграммы действий</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="activity-diagram.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase
>Диаграмма действий</phrase>
	  </textobject>
	  <caption>
	    <para
>Диаграмма действий </para>
	  </caption>
	</mediaobject>
</screenshot>
</para>
<para
>Диаграммы действий подобны процедурным диаграммам потока, с той разницей, что все действия напрямую присоединены к объектам.</para>

<para
>Диаграммы действий всегда ассоциируются с <emphasis
>классами</emphasis
>, <emphasis
>методами</emphasis
> или <emphasis
>вариантами действий</emphasis
>.</para>

<para
>Диаграммы действий поддерживают как последовательные, так и параллельные действия. Параллельное выполнение представляется с помощью пиктограмм Fork/Wait. Для действий, выполняющихся параллельно, порядок, в котором они выполняются, не имеет значения (они могут выполняться одновременно или друг за другом).</para>
<sect3 id="activity">
<title
>Действие</title>
<para
>Действие представляет собой один шаг процесса. Одно действие представляет одно состояние системы с внутренним действием и, как минимум, с одним результатом действия. Действия могут иметь более одного результата, если они происходят при разных условиях. </para
> 
<para
>Действия могут формировать иерархию, это означает, что действие может быть составлено из нескольких <quote
>мелких</quote
> действий. В этом случае входящие и исходящие переходы должны соответствовать входящим и исходящим переходам на детализированной диаграмме. </para>

</sect3>
</sect2
> <!-- activity diagram -->

<sect2 id="helper-elements">
<title
>Вспомогательные элементы</title>
<para
>Существует несколько вспомогательных элементов в &UML;, которые не имеют реального семантического значения для модели, но помогают внести ясность в диаграмму. Перечислим их: </para>
<itemizedlist>
<listitem
><para
>Текстовые строки</para
></listitem>
<listitem
><para
>Текстовые заметки и якоря</para
></listitem>
<listitem
><para
>Контейнеры</para
></listitem>
</itemizedlist
>   
<para
>Текстовые строки удобно использовать для добавления краткой текстовой информации в диаграмму, это свободно прикрепляемый текст, который ничего не значит для модели. </para
>           

<para
>Текстовые заметки следует использовать для добавления более детальной информации об объекте или о специфической ситуации. Текстовые заметки могут быть прикреплены к элементам &UML;. </para>

<para
>Контейнеры являются свободными прямоугольниками, которые могут быть использованы для группирования элементов диаграмм. Они не несут никакой смысловой нагрузки для модели.</para>

<!-- FIXME, screenshot -->
</sect2
> <!-- helper elements -->

<sect2 id="component-diagram">
<title
>Диаграммы компонентов</title>
<para
>Диаграммы компонентов отображают компоненты программного обеспечения (компонентные технологии, такие как KParts, CORBA или Java Beans или просто разделы системы, ясно отличающиеся друг от друга) и сущности, из которых они возникли, например, файлы с исходным кодом, библиотеки или таблицы баз данных.</para>

<para
>Компоненты обладают интерфейсами (то есть абстрактными классами с методами), которые позволяют создавать ассоциации между компонентами.</para>
</sect2>

<sect2 id="deployment-diagram">
<title
>Диаграммы выпуска</title>

<para
>Диаграммы выпуска отображают объекты, созданные во время выполнения программы, и их ассоциации. Они включают в себя узлы, которые являются физическими ресурсами, обычно одиночными компьютерами. Они также отображают интерфейсы и объекты.</para>

</sect2>

</sect1
> 
</chapter>
